# USR Routing Rules (Deterministic Semantic Routing)
Routing Logic for the Universal Semantic Runtime

This document defines how USR determines *where meaning should go* at each point in the execution pipeline.  
Routing is deterministic, invariant-bound, and domain-safe.

USR routing is the “semantic traffic controller” of USS.

---

# 1. Purpose of Routing

USR routing decides:

- **which subsystem handles which UST**
- **when meaning transitions between layers**
- **how multi-domain workflows remain consistent**
- **how invariants and safety rules are enforced**

Routing is a function:

Route(UST, Context) → Destination



Where `Destination` ∈ { USE, CE, Domain Engine, Inspector, Error Layer }

The routing engine never performs interpretation.  
It only *assigns meaning to the correct handler*.

---

# 2. Core Routing Principle

All routing follows this fundamental rule:

> Route based on **semantic type**, **invariant class**, and **domain-binding**, NOT surface form or natural language.

Meaning is routed because of what the UST *is*, not what words were used to create it.

---

# 3. Routing Destinations

USR routes USTs to one of five destinations.

## 3.1 USE – Semantic Execution
Send here when the UST:

- requires transformation  
- requires composition  
- requires enrichment  
- triggers a semantic operation  

Example triggers:

- temporal relation  
- predicate transformation  
- role filling  
- reference linking  
- causal chain reconstruction  

---

## 3.2 CE – Cognitive Engine
Send here when the UST:

- requires evaluation  
- requires explanation  
- requires modeling  
- requires justification or selection  
- initiates a reasoning posture  

CE is used for reasoning, not operations.

---

## 3.3 Domain Engine (SynCE, FinCE, QLE, etc.)
Send here when the UST:

- has a domain-binding  
- contains domain-specific invariants  
- requires domain-restricted interpretation  
- enters a specialized reasoning space  

Examples:

- MEDICAL_DIAGNOSIS → SynCE  
- TRADE_ORDER → FinCE  
- QUEST_NODE → QLE  

USR ensures **no UST enters a domain engine without validation**.

---

## 3.4 Inspector (Debug / Explain Mode)
Send here when:

- developer mode is active  
- invariants need visualization  
- plan debugging is requested  
- routing conflicts exist  

---

## 3.5 Error Layer
Send here when:

- invariants fail  
- domain boundaries violated  
- semantic types don’t unify  
- plan cannot be constructed  

USR errors are always deterministic, never ambiguous.

---

# 4. Routing Rule Hierarchy

Routing follows a five-tier rule hierarchy.  
Rules are applied *top-down*.

Type-Based Rules

Invariant-Based Rules

Domain-Boundary Rules

Contextual Rules

Plan-Level Rules

yaml
Copy code

The first matching rule wins.

---

# 5. Rule Tier 1 — Type-Based Routing

All USTs have a semantic type.  
Routing by type is the most common rule.

Examples:

- **Event** → USE  
- **Entity** → USE  
- **Goal** → CE  
- **Decision** → CE  
- **MedicalClaim** → SynCE  
- **TradeToken** → FinCE  

Routing by type is deterministic and schema-driven.

---

# 6. Rule Tier 2 — Invariant-Based Routing

Invariants override type rules.

If a UST contains:

- **Safety-critical invariants** → CE  
- **Domain-locked invariants** → Domain Engine  
- **Cross-domain invariants** → USE → CE pipeline  

Examples:

- `requires_justification=true` → CE  
- `domain_lock=medical` → SynCE  
- `compositional_strict=true` → USE  

Invariants prevent routing chaos.

---

# 7. Rule Tier 3 — Domain-Boundary Rules

If processing a UST would cross a domain boundary:

USR blocks → reroutes → requests clarification → or flags error

vbnet
Copy code

Example:

A financial UST tries to influence a medical decision:

BoundaryError: domain_violation (finance → medical)

yaml
Copy code

Domain boundaries are **mandatory walls**, not suggestions.

---

# 8. Rule Tier 4 — Contextual Routing

USR maintains a temporary context state:

- current task domain  
- active reasoning posture  
- execution phase  
- enabled modules  
- previously validated USTs  

Contextual rules guide routing when:

- the UST is part of a multi-step plan  
- the UST is subordinate to another UST  
- the plan currently expects a specific subsystem  

Example:

If CE is mid-reasoning, USTs generated by CE → loop back to CE unless tagged with:

requires_operation=true



---

# 9. Rule Tier 5 — Plan-Level Routing

During execution, the plan itself dictates routing.

Plans specify the required subsystem for each step:

STEP 1 → USE
STEP 2 → USE
STEP 3 → CE
STEP 4 → FinCE
STEP 5 → CE


USR enforces plan-level routing strictly.  
Plans cannot be changed mid-execution unless allowed by invariants.

---

# 10. Decision Table (Condensed)

| UST Feature                      | Route To     |
|---------------------------------|--------------|
| transformation needed            | USE          |
| composition needed               | USE          |
| justification required           | CE           |
| strategy or modeling needed      | CE           |
| domain-binding present           | Domain Eng.  |
| invariant: `strict_causal`       | USE          |
| invariant: `domain_lock`         | Domain Eng.  |
| ambiguous meaning                | CE           |
| unsafe or conflicting UST        | Error Layer  |

---

# 11. Routing Algorithm (Pseudo-Code)

function ROUTE(ust, context):

kotlin
Copy code
if violates_invariants(ust):
    return ERROR

if ust.domain_lock:
    return ROUTE_TO_DOMAIN_ENGINE(ust)

if requires_justification(ust):
    return CE

if requires_transformation(ust):
    return USE

if context.active_engine:
    return context.active_engine

if requires_modeling(ust):
    return CE

return USE


Deterministic. Predictable. Auditable.

---

# 12. Summary

USR routing is:

- deterministic  
- safety-first  
- invariant-governed  
- domain-aware  
- plan-aligned  

Routing ensures that:

UST goes to the right engine →
for the right operation →
under the right invariants →
with no domain contamination.

csharp
Copy code

USR routing is the backbone of semantic coherence.

Routing = semantic discipline.
